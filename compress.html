<!DOCTYPE html><html><head><title>Connect - High quality middleware for node.js</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link rel="stylesheet" href="style.css"><script src="jquery.js"></script><script src="docs.js"></script></head><body><div id="content"><h1>Connect</h1><div id="exports.methods" class="comment"><h2>exports.methods</h2><div class="description"><p>Supported content-encoding methods.</p></div><h3>Source</h3><pre><code>exports.methods = {
    gzip: zlib.createGzip
  , deflate: zlib.createDeflate
};</code></pre></div><div id="exports.filter" class="comment"><h2>exports.filter()</h2><div class="description"><p>Default filter function.</p></div><h3>Source</h3><pre><code>exports.filter = function(req, res){
  return /json|text|javascript|dart|image\/svg\+xml|application\/x-font-ttf|application\/vnd\.ms-opentype|application\/vnd\.ms-fontobject/.test(res.getHeader('Content-Type'));
};</code></pre></div><div id="module.exports" class="comment"><h2></h2><div class="description"><p>Compress:</p>

<p>Compress response data with gzip/deflate.</p>

<p>Filter:</p>

<p>A <code>filter</code> callback function may be passed to<br /> replace the default logic of:</p>

<pre><code>exports.filter = function(req, res){
  return /json|text|javascript/.test(res.getHeader('Content-Type'));
};
</code></pre>

<p>Threshold:</p>

<p>Only compress the response if the byte size is at or above a threshold.<br /> Always compress while streaming.</p>

<ul>
<li><code>threshold</code> - string representation of size or bytes as an integer.</li>
</ul>

<p>Options:</p>

<p>All remaining options are passed to the gzip/deflate<br /> creation functions. Consult node's docs for additional details.</p>

<ul>
<li><code>chunkSize</code> (default: 16*1024)</li>
<li><code>windowBits</code></li>
<li><code>level</code>: 0-9 where 0 is no compression, and 9 is slow but best compression</li>
<li><code>memLevel</code>: 1-9 low is slower but uses less memory, high is fast but uses more</li>
<li><code>strategy</code>: compression strategy</li>
</ul></div><ul class="tags"><li><em>Object</em> options </li><li>returns <em>Function</em> </li></ul><h3>Source</h3><pre><code>module.exports = function compress(options) {
  options = options || {};
  var filter = options.filter || exports.filter;
  var threshold;

  if (false === options.threshold || 0 === options.threshold) {
    threshold = 0
  } else if ('string' === typeof options.threshold) {
    threshold = utils.parseBytes(options.threshold)
  } else {
    threshold = options.threshold || 1024
  }

  return function compress(req, res, next){
    var accept = req.headers['accept-encoding']
      , write = res.write
      , end = res.end
      , compress = true
      , stream;

    // see #724
    req.on('close', function(){
      res.write = res.end = function(){};
    });

    // flush is noop by default
    res.flush = noop;

    // proxy

    res.write = function(chunk, encoding){
      if (!this.headerSent) {
        // if content-length is set and is lower
        // than the threshold, don't compress
        var length = res.getHeader('content-length');
        if (!isNaN(length) && length < threshold) compress = false;
        this._implicitHeader();
      }
      return stream
        ? stream.write(new Buffer(chunk, encoding))
        : write.call(res, chunk, encoding);
    };

    res.end = function(chunk, encoding){
      if (chunk) {
        if (!this.headerSent && getSize(chunk) < threshold) compress = false;
        this.write(chunk, encoding);
      } else if (!this.headerSent) {
        // response size === 0
        compress = false;
      }
      return stream
        ? stream.end()
        : end.call(res);
    };

    res.on('header', function(){
      // default request filter
      if (!filter(req, res)) return;

      // vary
      var vary = res.getHeader('Vary');
      if (!vary) {
        res.setHeader('Vary', 'Accept-Encoding');
      } else if (!~vary.indexOf('Accept-Encoding')) {
        res.setHeader('Vary', vary + ', Accept-Encoding');
      }

      if (!compress) return;

      var encoding = res.getHeader('Content-Encoding') || 'identity';

      // already encoded
      if ('identity' != encoding) return;

      // SHOULD use identity
      if (!accept) return;

      // head
      if ('HEAD' == req.method) return;

      // compression method
      var method = new Negotiator(req).preferredEncoding(['gzip', 'deflate', 'identity']);
      // negotiation failed
      if (method === 'identity') return;

      // compression stream
      stream = exports.methods[method](options);

      // overwrite the flush method
      res.flush = function(){
        stream.flush();
      }

      // header fields
      res.setHeader('Content-Encoding', method);
      res.removeHeader('Content-Length');

      // compression
      stream.on('data', function(chunk){
        write.call(res, chunk);
      });

      stream.on('end', function(){
        end.call(res);
      });

      stream.on('drain', function() {
        res.emit('drain');
      });
    });

    next();
  };
};

function getSize(chunk) {
  return Buffer.isBuffer(chunk)
    ? chunk.length
    : Buffer.byteLength(chunk);
}

function noop(){}</code></pre></div></div><ul id="menu"><li><a href="#exports.methods">exports.methods</a></li><li><a href="#exports.filter">exports.filter()</a></li><li><a href="#module.exports"></a></li></ul></body></html>