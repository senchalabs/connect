<!DOCTYPE html><html><head><title>Connect - High quality middleware for node.js</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link rel="stylesheet" href="style.css"><script src="jquery.js"></script><script src="docs.js"></script></head><body><div id="content"><h1>Connect</h1><div id="module.exports" class="comment"><h2></h2><div class="description"><h2>Static cache</h2>

<p>Enables a memory cache layer on top of<br />the <code>static()</code> middleware, serving popular<br />static files.</p>

<p>By default a maximum of 128 objects are<br />held in cache, with a max of 256k each,<br />totalling ~32mb.</p>

<p>A Least-Recently-Used (LRU) cache algo<br />is implemented through the <code>Cache</code> object,<br />simply rotating cache objects as they are<br />hit. This means that increasingly popular<br />objects maintain their positions while<br />others get shoved out of the stack and<br />garbage collected.</p>

<h2>Benchmarks</h2>

<pre><code>static(): 2700 rps
node-static: 5300 rps
static() + staticCache(): 7500 rps
</code></pre>

<h2>Options</h2>

<ul>
<li><code>maxObjects</code>  max cache objects [128]</li>
<li><code>maxLength</code>  max cache object length 256kb</li>
</ul></div><ul class="tags"><li><em>Object</em> options </li><li>returns <em>Function</em> </li></ul><h3>Source</h3><pre><code>module.exports = function staticCache(options){
  var options = options || {}
    , cache = new Cache(options.maxObjects || 128)
    , maxlen = options.maxLength || 1024 * 256;

  console.warn('connect.staticCache() is deprecated and will be removed in 3.0');
  console.warn('use varnish or similar reverse proxy caches.');

  return function staticCache(req, res, next){
    var key = cacheKey(req)
      , ranges = req.headers.range
      , hasCookies = req.headers.cookie
      , hit = cache.get(key);

    // cache static
    // TODO: change from staticCache() -> cache()
    // and make this work for any request
    req.on('static', function(stream){
      var headers = res._headers
        , cc = utils.parseCacheControl(headers['cache-control'] || '')
        , contentLength = headers['content-length']
        , hit;

      // dont cache set-cookie responses
      if (headers['set-cookie']) return hasCookies = true;

      // dont cache when cookies are present
      if (hasCookies) return;

      // ignore larger files
      if (!contentLength || contentLength > maxlen) return;

      // don't cache partial files
      if (headers['content-range']) return;

      // dont cache items we shouldn't be
      // TODO: real support for must-revalidate / no-cache
      if ( cc['no-cache']
        || cc['no-store']
        || cc['private']
        || cc['must-revalidate']) return;

      // if already in cache then validate
      if (hit = cache.get(key)){
        if (headers.etag == hit[0].etag) {
          hit[0].date = new Date;
          return;
        } else {
          cache.remove(key);
        }
      }

      // validation notifiactions don't contain a steam
      if (null == stream) return;

      // add the cache object
      var arr = [];

      // store the chunks
      stream.on('data', function(chunk){
        arr.push(chunk);
      });

      // flag it as complete
      stream.on('end', function(){
        var cacheEntry = cache.add(key);
        delete headers['x-cache']; // Clean up (TODO: others)
        cacheEntry.push(200);
        cacheEntry.push(headers);
        cacheEntry.push.apply(cacheEntry, arr);
      });
    });

    if (req.method == 'GET' || req.method == 'HEAD') {
      if (ranges) {
        next();
      } else if (!hasCookies && hit && !mustRevalidate(req, hit)) {
        res.setHeader('X-Cache', 'HIT');
        respondFromCache(req, res, hit);
      } else {
        res.setHeader('X-Cache', 'MISS');
        next();
      }
    } else {
      next();
    }
  }
};</code></pre></div><div id="respondFromCache" class="comment"><h2>respondFromCache()</h2><div class="description"><p>Respond with the provided cached value.<br />TODO: Assume 200 code, that's iffy.</p></div><ul class="tags"><li><em>Object</em> req </li><li><em>Object</em> res </li><li><em>Object</em> cacheEntry </li><li>returns <em>String</em> </li></ul><h3>Source</h3><pre><code>function respondFromCache(req, res, cacheEntry) {
  var status = cacheEntry[0]
    , headers = utils.merge({}, cacheEntry[1])
    , content = cacheEntry.slice(2);

  headers.age = (new Date - new Date(headers.date)) / 1000 || 0;

  switch (req.method) {
    case 'HEAD':
      res.writeHead(status, headers);
      res.end();
      break;
    case 'GET':
      if (utils.conditionalGET(req) && fresh(req.headers, headers)) {
        headers['content-length'] = 0;
        res.writeHead(304, headers);
        res.end();
      } else {
        res.writeHead(status, headers);

        function write() {
          while (content.length) {
            if (false === res.write(content.shift())) {
              res.once('drain', write);
              return;
            }
          }
          res.end();
        }

        write();
      }
      break;
    default:
      // This should never happen.
      res.writeHead(500, '');
      res.end();
  }
}</code></pre></div><div id="mustRevalidate" class="comment"><h2>mustRevalidate()</h2><div class="description"><p>Determine whether or not a cached value must be revalidated.</p></div><ul class="tags"><li><em>Object</em> req </li><li><em>Object</em> cacheEntry </li><li>returns <em>String</em> </li></ul><h3>Source</h3><pre><code>function mustRevalidate(req, cacheEntry) {
  var cacheHeaders = cacheEntry[1]
    , reqCC = utils.parseCacheControl(req.headers['cache-control'] || '')
    , cacheCC = utils.parseCacheControl(cacheHeaders['cache-control'] || '')
    , cacheAge = (new Date - new Date(cacheHeaders.date)) / 1000 || 0;

  if ( cacheCC['no-cache']
    || cacheCC['must-revalidate']
    || cacheCC['proxy-revalidate']) return true;

  if (reqCC['no-cache']) return true

  if (null != reqCC['max-age']) return reqCC['max-age'] < cacheAge;

  if (null != cacheCC['max-age']) return cacheCC['max-age'] < cacheAge;

  return false;
}</code></pre></div><div id="cacheKey" class="comment"><h2>cacheKey()</h2><div class="description"><p>The key to use in the cache. For now, this is the URL path and query.</p>

<p>'<a href='http://example.com?key=value'>http://example.com?key=value</a>' -> '/?key=value'</p></div><ul class="tags"><li><em>Object</em> req </li><li>returns <em>String</em> </li></ul><h3>Source</h3><pre><code>function cacheKey(req) {
  return utils.parseUrl(req).path;
}</code></pre></div></div><ul id="menu"><li><a href="#module.exports"></a></li><li><a href="#respondFromCache">respondFromCache()</a></li><li><a href="#mustRevalidate">mustRevalidate()</a></li><li><a href="#cacheKey">cacheKey()</a></li></ul></body></html>